#!/usr/bin/env python

"""TSG_SRV_v3.py: Management server for crypto_bridge from TSG projet"""

__author__ = "Titouan Mesot"
__copyright__ = "Copyright 2015 - Titouan Mesot"
__license__ = "APACHE2"
__version__ = "0.3"
__maintainer__ = "Titouan Mesot"
__email__ = "titouan.mesot@edu.hefr.ch"
__status__ = "Alpha"

import sys
import os
import struct
import ctypes
import zmq
import zmq.auth
import sqlite3
import hashlib
import io
import atexit
import struct
import time
import datetime
import logging
import signal
import random
from multiprocessing import Process, Queue

from zmq.utils.strtypes import bytes, unicode, b, u

from zmq.eventloop import ioloop, zmqstream
from zmq.auth.ioloop import IOLoopAuthenticator
from zmq.auth.thread import ThreadAuthenticator


ioloop.install()

import tornado
import tornado.web

crypto_secretbox_KEYBYTES = 32
seq_size = 32
max_int32_seq = 2147483647  # 2^31-1

#Queue between unsec / sec servers
q_param = Queue()
q_mgmt = Queue()

# parameters to send to bridges
# Type: 0 key + seq
#       1 commands (iptable and others)
#       2 firmware


class Params:
    def __init__(self, p_type, value, seq):
        self.t = p_type
        self.v = value
        self.seq = seq


# mgmt to send to the thread
# Type: 0 terminate


class ThMgmt:
    def __init__(self, action):
        self.action = action


#Handler for change key signal (SIGUSR1)
def usr_signal_handler(signal, frame):
        print "Key change ask from signal"
        random_key = os.urandom(crypto_secretbox_KEYBYTES,
                                random.randint(0, max_int32_seq))
        para = Params(0, random_key)
        q_param.put(para)


# Secure server thread
# q_param : queue for parameters
# q_mgmt  : queue for management thread management
def secure_srv(q_param, q_mgmt):
    #on thread start create current crypto key
    local = os.urandom(crypto_secretbox_KEYBYTES)
    # These directories are generated by the generate_certificates script
    base_dir = os.path.dirname(__file__)
    public_keys_dir = os.path.join(base_dir, 'public_keys')
    secret_keys_dir = os.path.join(base_dir, 'private_keys')

    if not(os.path.exists(public_keys_dir) and
            os.path.exists(secret_keys_dir)):
        logging.critical("Certificates are missing - add certificat first")
        sys.exit(1)

    ctx = zmq.Context()

    # Start an authenticator for this context.
    auth = ThreadAuthenticator(context=ctx, encoding='utf-8')
    auth.start()
    # Tell authenticator to use the certificate in a directory
    auth.configure_curve(domain='*', location=public_keys_dir)

    server = ctx.socket(zmq.PUB)
    server_secret_file = os.path.join(secret_keys_dir, "server.key_secret")
    server_public, server_secret = zmq.auth.load_certificate(
        server_secret_file
        )
    server.curve_secretkey = server_secret
    server.curve_publickey = server_public
    server.curve_server = True
    server.bind('tcp://*:5556')
    while(True):
        if not q_mgmt.empty():
            print "we rcv a mgmt msg"
            msg = q_mgmt.get()
            if msg.action == 0:
                print "we have to restart auth"
                auth.stop()
                auth = ThreadAuthenticator(context=ctx, encoding='utf-8')
                auth.start()
                auth.configure_curve(domain='*', location=public_keys_dir)
                print "Auth restarted"
        if not q_param.empty():
            print "we rcv a param msg"
            p = q_param.get()
            if p.t == 0:
                local = p.v
            #send new parameters with seq
            s_snd = struct.Struct('! B B H H H I')
            data = s_snd.pack(1, 6, 4, len(p.v), p.t, p.seq)
            server.send(data+str(p.v))
        #loop send key+seq if no new params
        key_param = Params(0, local, random.randint(0, max_int32_seq))
        s_snd = struct.Struct('! B B H H H I')
        data = s_snd.pack(
            1,
            6,
            4,
            len(key_param.v),
            key_param.t,
            key_param.seq
            )
        server.send(data+str(key_param.v))
        time.sleep(2)  # avoid "as fast as possible" loop

    # stop auth thread
    auth.stop()
    # stop zmq context
    ctx.destroy()
    return


#Write new trusted client key in public_keys dir
#pub_key : The trusted client public key


def write_key(pub_key):
    banner = u("""#   ****  Generated on {0} by tsg  ****
#   ZeroMQ CURVE Public Certificate
#   Exchange securely, or use a secure mechanism to verify the contents
#   of this file after exchange. Store public certificates in your home
#   directory, in the .curve subdirectory.
""")

    base_dir = os.path.dirname(__file__)
    public_keys_dir = os.path.join(base_dir, 'public_keys')
    key = pub_key.decode('utf-8')
    with io.open(
        public_keys_dir+"/"+str(hashlib.sha1(pub_key).hexdigest())
            + ".key", 'w', encoding='utf8') as f:

        f.write(banner.format(datetime.datetime.now()))
        f.write(u('metadata\n'))
        f.write(u('curve\n'))
        f.write(u("    public-key = \"{0}\"\n").format(pub_key))

    #If it's the first client we start the secure server
    if not p.is_alive():
        p.start()
    #stop secure_srv process and restart it to be able to auth new clients
    q_mgmt.put(ThMgmt(0))
    print "reauth sended"


###Database mgmt

def add_to_db(client_id, pub_key):
    c.execute("INSERT INTO clients VALUES (?,?,?)", (client_id, pub_key, 0))
    conn.commit()


def is_client_in_db(pub_key):
    c.execute('SELECT * FROM clients WHERE pub_key=?', (pub_key,))
    if c.fetchone() is not None:
        return True
    else:
        return False


def is_client_trusted(pub_key):
    c.execute('SELECT trusted FROM clients WHERE pub_key=?', (pub_key,))
    val = c.fetchone()
    if val[0] == 1:
        return True
    else:
        return False


def trust_in_db(pub_key):
    c.execute(
        'UPDATE clients SET trusted = ? WHERE pub_key=?',
        (True, pub_key,)
        )
    conn.commit()
    write_key(pub_key)


def get_clients_in_db():
    c.execute('SELECT * FROM clients')
    return c.fetchall()


# Unsecure connection rcv callback
# Take the zmq message (callback)
def rcv_unsec(stream):
    conn = sqlite3.connect('clients.db')
    c = conn.cursor()
    print "We rcv a new connection"
    s_rcv = struct.Struct('! B B H I 40s')
    version, payload_type, payload_size, client_id, pub_key = \
        s_rcv.unpack(stream[0])

    if payload_type == 0:
        if is_client_in_db(pub_key):
            if not is_client_trusted(pub_key):
                print "Client not trusted"
                s_snd = struct.Struct('@ B B H')
                data = s_snd.pack(1, 2, 0)
                server_unsec.send(data)
            else:
                print "Ok accepted"
                s_snd = struct.Struct('@ B B H')
                data = s_snd.pack(1, 1, 0)
                server_unsec.send(data)
                if not p.is_alive():
                    p.start()
        else:
            print "New client ID : {0} Public key : {1}" \
                .format(client_id, pub_key)

            add_to_db(client_id, pub_key)
            print "Wait until accept"
            s_snd = struct.Struct('@ B B H')
            data = s_snd.pack(1, 2, 0)
            server_unsec.send(data)
    else:
        print "Payload Type error : "+payload_type
        s_snd = struct.Struct('@ B B H')
        data = s_snd.pack(1, 2, 0)
        server_unsec.send(data)
    conn.close()

#### Web interface pages
iptables_template = """
iptables -A FORWARD -p 253 -i br-br0 -j NFQUEUE --queue-num 0 --queue-bypass &&
 iptables -A FORWARD -p {0} --dport {1} -i br-br0 -j NFQUEUE --queue-num 0 --queue-bypass &&
 iptables -A FORWARD -p {0} --sport {1} -i br-br0 -j NFQUEUE --queue-num 0 --queue-bypass
"""


class MainHandler(tornado.web.RequestHandler):
    def get(self):
        self.write("<p><b>Welcome to manager, we are waiting</b></p>")
        self.write(
            "<p>Menu :  <a href=./iptables> Iptables </a>" +
            "<a href=./key> Key MGMT </a>" +
            "<a href=./commands> Commands </a></p>"
            )
        clients = get_clients_in_db()
        for client in clients:
            self.write("<p>Id : "+str(client[0])+"  Pub key : "
                       +tornado.escape.xhtml_escape(client[1]))

            if is_client_trusted(
                    tornado.escape.xhtml_unescape(client[1])
            ) is True:
                self.write("This key is already trusted </p>")
            else:
                self.write("<a href=./add/" +
                           tornado.escape.url_escape(client[1]) +
                           "> Trust It ! </a>  </p>")


class FunctionHandler(tornado.web.RequestHandler):
    def get(self, id):
        self.write("<p><b>Adding trusted client (" +
                   tornado.escape.xhtml_escape(id)+")</b></p>")

        trust_in_db(id)
        self.write("<p><b>Done !</b></p>")
        self.write("<p><a href=../>Back to main menu</a></p>")


class CommandsHandler(tornado.web.RequestHandler):
    def get(self):
        self.write("<p><b>Commands sending to all devices</b></p>")
        self.write("""
<form action="./commands" method="POST">
command to send: <br>
<input type="text" name="rules" value="touch /tmp/HelloWorld">
<input type="submit" value="Submit">
</form>
        """)

        self.write("<p><a href=../>Back to main menu</a></p>")

    def post(self):
        self.write("<p><b>Sending command to devices ...</b></p>")
        q_param.put(Params(1, self.get_argument("rules"),
                           random.randint(0, max_int32_seq)))

        self.write("<p><b>Done !</b></p>")
        self.write("<p><a href=../>Back to main menu</a></p>")


class IptablesHandler(tornado.web.RequestHandler):
    def get(self):
        self.write("<p><b>Protocol to encrypt</b></p>")
        self.write("""
<form action="./iptables" method="post">
<div class="row requiredRow">
    <label for="txt_port" id="port-ariaLabel">port</label>
    <input id="txt_port" name="txt_port" type="text"
    aria-labelledby="port-ariaLabel" class="required" title="port.
    This is a required field">
</div>
<div class="row requiredRow">
    <label for="sel_protocol" id="protocol-ariaLabel">protocol</label>
    <select id="sel_protocol" name="sel_protocol"
    aria-labelledby="protocol-ariaLabel"
    class="required" title="protocol. This is a required field">
        <option value="udp">udp</option>
        <option value="tcp">tcp</option>
    </select>
</div>
<input type="hidden" name="reset" value="0">
<div class="row">
<input type="submit" value="Send">
</div>
</form>
        """)
        self.write("""
<form action="./iptables" method="post">
<div class="row">
<input type="hidden" name="reset" value="1">
<input type="submit" value="Remove all rules">
</div>
</form>
        """)
        self.write("<p><a href=../>Back to main menu</a></p>")

    def post(self):
        if self.get_argument("reset") == "0":
            self.write("<p><b>Sending iptables rules to devices ...</b></p>")

            ipr = iptables_template.format(
                self.get_argument("sel_protocol"),
                self.get_argument("txt_port"))

            q_param.put(Params(1, ipr, random.randint(0, max_int32_seq)))
            self.write("<p><b>Done !</b></p>")
            self.write("<p><a href=../>Back to main menu</a></p>")
        else:
            self.write("<p><b>Removing all rules</b></p>")

            q_param.put(Params(
                        1,
                        "iptables -F && iptables -X",
                        random.randint(0, max_int32_seq)))

            self.write("<p><b>Done !</b></p>")
            self.write("<p><a href=../>Back to main menu</a></p>")


class KeyHandler(tornado.web.RequestHandler):
    def get(self):
        self.write("<p><b>Key Management interface</b></p>")
        self.write("""
<form action="./key" method="post">
<div class="row">
<input type="submit" value="Change key">
</div>
</form>
        """)
        self.write("<p><a href=../>Back to main menu</a></p>")

    def post(self):
        self.write("<p><b>Sending new key to devices ...</b></p>")

        q_param.put(Params(
                    0,
                    os.urandom(crypto_secretbox_KEYBYTES),
                    random.randint(0, max_int32_seq)))

        self.write("<p><b>Done !</b></p>")
        self.write("<p><a href=../>Back to main menu</a></p>")


### ZMQ unsec_srv setup
def setup_server_unsec(server_unsec,
                       server_secret_file,
                       endpoint='tcp://*:5555'):

    server_public, server_secret = zmq.auth.load_certificate(
        server_secret_file)
    server_unsec.curve_secretkey = server_secret
    server_unsec.curve_publickey = server_public
    server_unsec.curve_server = True  # must come before bind
    server_unsec.bind(endpoint)
    server_stream_unsec = zmqstream.ZMQStream(server_unsec)
    server_stream_unsec.on_recv(rcv_unsec, copy=True)
    return server_stream_unsec

### HTTP srv hook page Handler
application = tornado.web.Application([
                                      (r"/", MainHandler),
                                      (r"/add/([^/]+)", FunctionHandler),
                                      (r"/commands", CommandsHandler),
                                      (r"/iptables", IptablesHandler),
                                      (r"/key", KeyHandler),
                                      ])


#start unsecure zmq server

base_dir = os.path.dirname(__file__)
public_keys_dir = os.path.join(base_dir, 'public_keys')
secret_keys_dir = os.path.join(base_dir, 'private_keys')

# Start an authenticator for this context.
ctx_server_unsec = zmq.Context()
server_unsec = ctx_server_unsec.socket(zmq.REP)
auth_unsec = IOLoopAuthenticator()
auth_unsec.configure_curve(domain='*', location='*')
server_secret_file = os.path.join(secret_keys_dir, "server.key_secret")
server_unsec = setup_server_unsec(server_unsec, server_secret_file)
server_public_file = os.path.join(public_keys_dir, "server.key")
auth_unsec.start()


### Start

if __name__ == "__main__":

    application.listen(8888)
    io_loop = ioloop.IOLoop.instance()
    conn = sqlite3.connect('clients.db')
    c = conn.cursor()
    sql = 'create table if not exists' \
    ' clients (id integer, pub_key text, trusted boolean)'
    c.execute(sql)
    conn.commit()
    signal.signal(signal.SIGUSR1, usr_signal_handler)
    p = Process(target=secure_srv, args=(q_param, q_mgmt,))
    io_loop.start()
